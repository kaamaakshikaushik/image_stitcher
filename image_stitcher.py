# -*- coding: utf-8 -*-
"""image_stitcher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dA_NbTLw_ngma_zRsmdVVFCL8v7kX5k7
"""

!pip install opencv-python matplotlib numpy

# Image upload
' Image sourced from-https://unsplash.com/photos/city-skyline-across-body-of-water-during-night-time-xjrvTc52xYchttps://images.unsplash.com/photo-1597172300672-dbcdf33ac44e?ixlib=rb-4.1.0&q=85&fm=jpg&crop=entropy&cs=srgb&dl=serey-kim-xjrvTc52xYc-unsplash.jpg '

from google.colab import files
uploaded = files.upload()

"""
Image stitching code- this code first splits the downloaded panorama image(dowload link provided) into tiles with overlap.
The individual tiles are then stitched back together using a simple alpha blending method.
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple
import os

class ImageStitcher:
    """
    A class to split images into tiles and stitch them back together.
    """

    def __init__(self, overlap_percent: float = 0.4):
        """
        Initialize the ImageStitcher.

        Args:
            overlap_percent: Percentage of overlap between tiles (0.0 to 1.0)
        """
        # Set overlap percentage and placeholders for tiles and positions

        self.overlap_percent = overlap_percent
        self.tiles = []
        self.tile_positions = []
        self.original_shape = None

    def split_image(self, image: np.ndarray, num_tiles: int = 4) -> List[np.ndarray]:
        """
        Split an image into overlapping tiles.

        """
        self.original_shape = image.shape
        height, width = image.shape[:2]
        self.original_width = width

        # Calculate step size (distance between tile starts)
        # With overlap_percent = 0.4, each tile overlaps 40% with the next
        # So effective step is 60% of tile width
        effective_coverage = 1.0 - self.overlap_percent  # 0.6 for 40% overlap
        step_size = int(width * effective_coverage / num_tiles)

        # Calculate tile width to ensure proper overlap
        tile_width = int(step_size / effective_coverage)  # This gives us the full tile width

        tiles = []
        positions = []

        print(f"\n=== Image Splitting Details ===")
        print(f"Original size: {width}x{height}")
        print(f"Number of tiles: {num_tiles}")
        print(f"Step size: {step_size}px")
        print(f"Tile width: {tile_width}px")
        print(f"Overlap: {tile_width - step_size}px ({self.overlap_percent*100:.0f}%)\n")

        for i in range(num_tiles):
            start_x = i * step_size
            end_x = start_x + tile_width

            # Ensure last tile reaches exactly to the end
            if i == num_tiles - 1:
                end_x = width
            else:
                end_x = min(end_x, width)

            tile = image[:, start_x:end_x].copy()
            tiles.append(tile)
            positions.append((start_x, end_x))

            overlap_with_next = tile_width - step_size if i < num_tiles - 1 else 0
            print(f"Tile {i+1}: x=[{start_x:4d}:{end_x:4d}], width={end_x-start_x:4d}px, overlap with next={overlap_with_next}px")

        self.tiles = tiles
        self.tile_positions = positions
        return tiles

    def stitch_tiles_simple(self, tiles: List[np.ndarray]) -> np.ndarray:
        """
        Stitch tiles back together using simple alpha blending.

        """
        if len(tiles) == 0:
            return None
        if len(tiles) == 1:
            return tiles[0]

        print("\n=== Stitching Process ===")

        # Use original width to ensure we reconstruct the full image
        actual_width = self.original_width
        height = tiles[0].shape[0]
        channels = tiles[0].shape[2] if len(tiles[0].shape) == 3 else 1

        print(f"Output canvas size: {actual_width}x{height}")

        # Create output canvas
        if channels > 1:
            result = np.zeros((height, actual_width, channels), dtype=np.uint8)
        else:
            result = np.zeros((height, actual_width), dtype=np.uint8)

        # Place first tile
        start_x, end_x = self.tile_positions[0]
        result[:, start_x:end_x] = tiles[0]
        print(f"Placed Tile 1 at x=[{start_x}:{end_x}]")

        # Stitch remaining tiles with blending
        for i in range(1, len(tiles)):
            current_start, current_end = self.tile_positions[i]
            prev_start, prev_end = self.tile_positions[i-1]

            # Calculate overlap region
            overlap_start = current_start
            overlap_end = min(prev_end, current_end)
            overlap_width = overlap_end - overlap_start

            tile = tiles[i]

            if overlap_width > 0:
                # Blend in overlap region
                # Position in the tile
                tile_overlap_start = overlap_start - current_start
                tile_overlap_end = tile_overlap_start + overlap_width

                # Create alpha blend weights
                alpha = np.linspace(0, 1, overlap_width)
                if channels > 1:
                    alpha = alpha.reshape(1, -1, 1)
                else:
                    alpha = alpha.reshape(1, -1)

                # Blend the overlapping region
                existing = result[:, overlap_start:overlap_end].astype(np.float32)
                incoming = tile[:, tile_overlap_start:tile_overlap_end].astype(np.float32)

                blended = (existing * (1 - alpha) + incoming * alpha).astype(np.uint8)
                result[:, overlap_start:overlap_end] = blended

                # Place non-overlapping part of current tile
                if overlap_end < current_end:
                    tile_non_overlap_start = tile_overlap_end
                    result[:, overlap_end:current_end] = tile[:, tile_non_overlap_start:]

                print(f"Blended Tile {i+1} at x=[{current_start}:{current_end}], overlap={overlap_width}px")
            else:
                # Placing the tile when no overlap
                result[:, current_start:current_end] = tile
                print(f"Placed Tile {i+1} at x=[{current_start}:{current_end}], no overlap")

        print(f"Final stitched width: {result.shape[1]}px (target: {actual_width}px)")

        return result

    def stitch_tiles(self, tiles: List[np.ndarray]) -> np.ndarray:
        """
        Main stitching method - uses simple blending for split tiles
        """
        return self.stitch_tiles_simple(tiles)


def main():
    """
    Main function to demonstrate image splitting and stitching.
    """
    # Create output directory
    os.makedirs('output', exist_ok=True)

    # Load the panoroma image
    print("=" * 60)
    print("IMAGE TILE STITCHING PROJECT")
    print("=" * 60)
    print("\nLoading panoroma image...")
    image_path = 'panoroma.jpg'

    if not os.path.exists(image_path):
        print(f"Error: {image_path} not found!")
        print("Please upload your panoroma.jpg file.")
        return

    img = cv2.imread(image_path)

    if img is None:
        print(f"Error: Could not read {image_path}")
        return

    print(f"Loaded successfully!")
    print(f"Original image size: {img.shape[1]}x{img.shape[0]} pixels")

    # Initialize stitcher with 40% overlap
    stitcher = ImageStitcher(overlap_percent=0.4)

    # Split into tiles
    num_tiles = 4
    tiles = stitcher.split_image(img, num_tiles=num_tiles)

    # Save tiles
    print("\n=== Saving Tiles ===")
    for i, tile in enumerate(tiles):
        tile_path = f'output/tile_{i+1}.jpg'
        cv2.imwrite(tile_path, tile)
        print(f"Tile Saved: {tile_path}")

    # Stitch tiles back together
    stitched = stitcher.stitch_tiles(tiles)

    # Save stitched result
    output_path = 'output/stitched_result.jpg'
    cv2.imwrite(output_path, stitched)
    print(f"\nStitched image saved: {output_path}")
    print(f"Stitched image size: {stitched.shape[1]}x{stitched.shape[0]} pixels")

    # Calculate accuracy
    original_shape = img.shape
    stitched_shape = stitched.shape

    print("\n=== Quality Check ===")
    print(f"Original:  {original_shape[1]}x{original_shape[0]}")
    print(f"Stitched:  {stitched_shape[1]}x{stitched_shape[0]}")

    if original_shape == stitched_shape:
        print("Perfect reconstruction - dimensions match! Yippie!!")

        # Calculate pixel difference
        diff = cv2.absdiff(img, stitched)
        avg_diff = np.mean(diff)
        print(f"Average pixel difference: {avg_diff:.2f}")

        if avg_diff < 1.0:
            print("Excellent! Nearly perfect reconstruction.")
        elif avg_diff < 5.0:
            print("Good reconstruction with minor differences.")
        else:
            print("Some differences detected (likely from compression).")
    else:
        print("Dimensions don't match exactly")

    # Display results
    print("\n=== Creating Visualization ===")
    plt.figure(figsize=(20, 12))

    # Show original
    plt.subplot(3, 3, 1)
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
    plt.title(f'Original Panorama\n{img.shape[1]}x{img.shape[0]}px', fontsize=12, fontweight='bold')
    plt.axis('off')

    # Show tiles
    for i, tile in enumerate(tiles):
        plt.subplot(3, 3, i+2)
        plt.imshow(cv2.cvtColor(tile, cv2.COLOR_BGR2RGB))
        plt.title(f'Tile {i+1}\n{tile.shape[1]}x{tile.shape[0]}px', fontsize=10)
        plt.axis('off')

    # Show stitched result
    plt.subplot(3, 3, 7)
    plt.imshow(cv2.cvtColor(stitched, cv2.COLOR_BGR2RGB))
    plt.title(f'Stitched Result\n{stitched.shape[1]}x{stitched.shape[0]}px', fontsize=12, fontweight='bold')
    plt.axis('off')

    # Show difference if dimensions match
    if original_shape == stitched_shape:
        plt.subplot(3, 3, 8)
        diff = cv2.absdiff(img, stitched)
        diff_display = cv2.cvtColor(diff, cv2.COLOR_BGR2RGB)
        plt.imshow(diff_display)
        plt.title(f'Difference Map\nAvg: {np.mean(diff):.2f}', fontsize=10)
        plt.axis('off')

    plt.tight_layout()
    comparison_path = 'comparison.png'
    plt.savefig(comparison_path, dpi=150, bbox_inches='tight')
    print(f"Comparison saved: {comparison_path}")
    plt.show()

    print("\n" + "=" * 60)
    print("PROCESS COMPLETE!")
    print("=" * 60)
    print("\nGenerated files:")
    print("  - tile_1.jpg to tile_4.jpg")
    print("  - stitched_result.jpg")
    print("  - comparison.png")


if __name__ == "__main__":
    main()

from IPython.display import Image, display
display(Image('output/comparison.png'))